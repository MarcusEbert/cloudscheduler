#!/usr/bin/env python3
"""
Back up the structure of all tables in the csv2 database. For those tables listed in
gvar['backup_data'] (see the main function) also backup the data.
"""
from cloudscheduler.lib.db_config import Config
from subprocess import Popen, PIPE
from tempfile import mkdtemp
import datetime
import os
import shutil
import socket
import sys
import yaml

def decode(gvar, obj):
    if isinstance(obj, str):
        return obj
    else:
        return obj.decode('utf-8')
    
def backup(gvar, table, backup_dir, data=False):
    """
    Perform backup, with or without data. The backup is performed to a temporary directory
    and only moved to the permanent directory if the table has changed. Since the backup
    directories are part of a git repository, this procedure reduces the number of commits.
    """

    print(table)

    if data:
        backup_cmd = [
            'mysqldump',
            '-u%s' % gvar['db_config'].db_config['db_user'],
            '-p%s' % gvar['db_config'].db_config['db_password'],
            gvar['db_config'].db_config['db_name'],
            table
            ]
    else:
        backup_cmd = [
            'mysqldump',
            '-u%s' % gvar['db_config'].db_config['db_user'],
            '-p%s' % gvar['db_config'].db_config['db_password'],
            '--no-data',
            gvar['db_config'].db_config['db_name'],
            table
            ]


    _p1 = Popen(
        backup_cmd,
        stdout=PIPE,
        stderr=PIPE
        )
    stdout, stderr = _p1.communicate()
    if _p1.returncode != 0:
        print('Failed to retrieve table definition for: %s' % table)
#       exit(1)

    _fd = open('%s/%s' % (gvar['temp_dir'], table), 'w')
    _fd.write(decode(gvar, stdout))
    _fd.close()

    if os.path.isfile('%s/%s' % (backup_dir, table)):
        _p1 = Popen(
            [
                'diff',
                '%s/%s' % (backup_dir, table),
                '%s/%s' % (gvar['temp_dir'], table)
                ],
            stdout=PIPE,
            stderr=PIPE
            )
        _p2 = Popen(
            [
                'awk',
                '/^<|^>/ && !/Dump completed on /'
                ],
            stdin=_p1.stdout,
            stdout=PIPE,
            stderr=PIPE
            )
        stdout, stderr = _p2.communicate()
        if _p2.returncode != 0:
            print('Failed to compare table definition for: %s' % table)
            exit(1)
    else:
        stdout = 'missing'

    if decode(gvar, stdout) != '':
        _p1 = Popen(
            [
                'mv',
                '-f',
                '%s/%s' % (gvar['temp_dir'], table),
                '%s/%s' % (backup_dir, table)
                ],
            stdout=PIPE,
            stderr=PIPE
            )
        stdout, stderr = _p1.communicate()
        if _p1.returncode != 0:
            print('Failed to update table definition for: %s - %s' % (table, stderr))
            exit(1)

        print('Updated table definition for: %s' % table)

def main(args):
    """
    Retrieve the table list from the database, and for each table backup the structure and,
    if listed in the gvar['table_config']['global'] variable, backup the data as well.
    """

    gvar = { 'cmd_path': os.path.abspath(args[0]) }

    gvar['db_config'] = Config('/etc/cloudscheduler/cloudscheduler.yaml', [], db_config_dict=True)
    
    gvar['path_info'] = gvar['cmd_path'].split('/')
    gvar['ix'] = gvar['path_info'].index('cloudscheduler')
    gvar['temp_dir'] = mkdtemp()
    
    gvar['backup_dir'] = '%s/schema/schema_backup/%s' % ('/'.join(gvar['path_info'][:gvar['ix']+1]), socket.getfqdn())
    if not os.path.isdir(gvar['backup_dir']):
         os.makedirs(gvar['backup_dir'], 0o755)
         
    gvar['config_file_path'] = '%s/etc/schema_backup.conf' % '/'.join(gvar['path_info'][:gvar['ix']+1])
    if os.path.isfile(gvar['config_file_path']):
        fd = open(gvar['config_file_path'])
        gvar['table_config'] = yaml.load(fd.read())
        fd.close()
    else:
        gvar['table_config'] = {'global': []}

    if 'local_backup_dir' in gvar['table_config']:
        gvar['local_backup_dir'] = '%s/%s' % (gvar['table_config']['local_backup_dir'], datetime.datetime.now().strftime('%Y%m%d%H%M%S'))

    _p1 = Popen(
        [
            'mysql',
            '-u%s' % gvar['db_config'].db_config['db_user'],
            '-p%s' % gvar['db_config'].db_config['db_password'],
            '-e',
            'show tables;',
            gvar['db_config'].db_config['db_name']
            ],
        stdout=PIPE,
        stderr=PIPE
        )
    _p2 = Popen(
        [
            'awk',
            '!/Tables_in_/ {print $1}'
            ],
        stdin=_p1.stdout,
        stdout=PIPE,
        stderr=PIPE
        )
    stdout, stderr = _p2.communicate()
    if _p2.returncode != 0:
        print('Failed to retrieve table list.')
        exit(1)

    print('\ncsv2 schema-backup starting...')

    tables = decode(gvar, stdout).split('\n')
    for table in tables:
        if len(table) > 0 and (len(table) < 5 or table[:5] != 'view_'):
            if 'global' in gvar['table_config'] and table in gvar['table_config']['global']:
                backup(gvar, table, gvar['backup_dir'], data=True)
            else:
                backup(gvar, table, gvar['backup_dir'])

    print('\ncsv2 schema-backup starting local backups...')

    if 'local_backup_dir' in gvar and 'local' in gvar['table_config'] and len(gvar['table_config']['local']) > 0:
        os.makedirs(gvar['local_backup_dir'], 0o640)

        try:
            os.unlink('%s/latest' % gvar['table_config']['local_backup_dir'])
        except:
            pass

        os.symlink(gvar['local_backup_dir'], '%s/latest' % gvar['table_config']['local_backup_dir'])

        for table in gvar['table_config']['local']:
            backup(gvar, table, gvar['local_backup_dir'], data=True)

#   shutil.rmtree(gvar['temp_dir'])
    print('csv2 schema-backup completed.')

if __name__ == "__main__":
    main(sys.argv)
