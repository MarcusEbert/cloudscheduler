#!/usr/bin/env python3
"""
Synopsis: utilities/list_views [ map ]

This command produces one of two reports: 1. without the "map" option, list the view names 
in the order they need to be created, or 2. with the "map" option, prints a report showing
view dependencies.
"""

from cloudscheduler.lib.db_config import Config
from subprocess import Popen, PIPE
import curses
import json
import os
import sys
import tempfile
import time
import traceback

LOG_FILE_MAP_SFX = '.map'

def generate_log_file_map(watch, log_dir, log_file_name, extend=[]):
    watch_xref = {}
    for ix in range(len(watch)):
        watch_xref[watch[ix]['id']] = ix

    cmd = None
    frames = extend

    # Set master frame for each command within the frames.
    if len(frames) > 0:
        cmd_fix = [0]*len(watch)
        for fix in range(len(frames)-1, -1, -1):
            for ix in range(len(frames[fix]['cmd'])):
                if ix < len(cmd_fix) and cmd_fix[ix] == 0 and fix == frames[fix]['cmd'][ix][1]:
                    watch[ix]['fix'] = fix
                    cmd_fix[ix] = 1

#           if extend:
#               print(">>> %s %s %s %s %s" % (len(extend), fix, ix, cmd_fix, frames[fix]['cmd'][ix][1]))

            if cmd_fix == [1]*len(watch):
                break

    with open('%s/%s' % (log_dir, log_file_name)) as fd:
        if len(frames) > 0:
            offset = frames[-1]['fsize']
            fd.seek(offset)
        else:
            offset = 0

        for line in fd:
            words = line[:-1].split()
            if len(words) > 0 and words[0] in watch_xref:
                if watch_xref[words[0]] == 0:
                    frames.append({'cmd': []})

                if len(frames) > 0:
                    cmd = watch[watch_xref[words[0]]]
                    if 'fix' not in cmd:
                        cmd['fix'] = -1
                    
                    if len(words) > 1 and words[1][0] == '(':
                        cmd['fix'] = len(frames)-1

                    frames[-1]['cmd'].append([offset, cmd['fix']])

            elif 'condor_q' in watch_xref:
                if 'dd' not in frames[-1]:
                    date = words[-2].split('/')
                    time = words[-1].split(':')
                    frames[-1]['dd'] = (((int(date[2])*100)+int(date[0]))*100)+int(date[1])
                    frames[-1]['hr'] = time[0]*1

            offset += len(line)

    if 'dd' in frames[-1]:
        frames[-1]['fsize'] = offset
    else:
        if len(frames) > 1:
            frames[-2]['fsize'] = frames[-1]['cmd'][0]
        del frames[-1]

    with open('%s/%s%s' % (log_dir, log_file_name, LOG_FILE_MAP_SFX), 'w') as fd:
        fd.write(json.dumps(frames))

    return frames

if len(sys.argv) < 2:
    if sys.stdout.isatty():
        report_destination = 'terminal'
    else:
        print('Error: no option specified and no terminal attached.')
        exit(1)

else:
    if sys.argv[1] == '?' or sys.argv[1] == '-h' or sys.argv[1] == '--help' or sys.argv[1] == 'help':
        print('\nSynopsis: watch_csv2 [ <option> ]' \
            '\n\nWhere "<option>" is one of the following:' \
            '\n   --help       - (or: -h, help, & ?) to request these help messages.' \
            '\n   --append     - (or: -a, append) appends periodical reports to the system log file.' \
            '\n   --enumerate  - (or: -e, enumerate) reads the system log file, identifies data' \
            '\n                  elements by inserting table, row, and column identifiers, and' \
            '\n                  writing the report to stdout.' \
            '\n   --map <path> - (or: -m, map) reads the specified log file and creates a log file map.' \
            '\n   --replay     - (or: -r, replay) replays the system log file.' \
            '\n\nIf no option is specified and a tty is attached, the report is writtin to the terminal.' \
            '\n\nwatch_csv2 has the following configuration values within the csv2 database:' \
            '\n   category=watch_csv2, key=config_file - specifies the absolute path of the watch_csv2' \
            '\n                                          configuration file. This file specifies the' \
            '\n                                          commands and SQL select statements that are to' \
            '\n                                          be "watched". Each command/statement must be' \
            '\n                                          terminated by a semicolon (";").' \
            '\n   category=watch_csv2, key=log_file    - specifies the absolute path of the watch_csv2' \
            '\n                                          log file.' \
            '\n   category=watch_csv2, key=sleep_time  - specifies the number of seconds between periodic' \
            '\n                                          reports.')

        exit(0)

    elif sys.argv[1] == '--append' or sys.argv[1] == '-a' or sys.argv[1] == 'append':
        report_destination = 'syslog'

    elif sys.argv[1] == '--enumerate' or sys.argv[1] == '-e' or sys.argv[1] == 'enumerate':
        report_destination = 'enumerate'

    elif sys.argv[1] == '--map' or sys.argv[1] == '-m' or sys.argv[1] == 'map':
        report_destination = 'map'

    elif sys.argv[1] == '--replay' or sys.argv[1] == '-r' or sys.argv[1] == 'replay':
        report_destination = 'replay'

    else:
        print('Error: parameter "%s" is unregognized.' % sys.argv[1])
        exit(1)

config = Config('/etc/cloudscheduler/cloudscheduler.yaml', ['watch_csv2'], db_config_dict=True)

if not os.path.isfile(config.config_file):
    print('Error: Configuration file "%s" does not exist.' % sys.argv[1])
    exit(1)

fd = open(config.config_file)
watch_list = fd.read().replace('\n', ' ').split(';')
fd.close()

watch = []
for ix in range(len(watch_list)):
    watch_words = watch_list[ix].split()
    if len(watch_words) > 0 and watch_words[0][0] != '#':
        if watch_words[0] == 'select':
            from_ix = -1 
            while True:
                try:
                    from_ix = watch_words.index('from', from_ix+1)
                except ValueError:
                    break

            watch.append({
                'id': watch_words[from_ix+1],
                'ix': ix,
                'type': 'SQL',
                'command': watch_list[ix],
                'diff': '********'
                })

        else:
            watch.append({
                'id': watch_words[0],
                'ix': ix,
                'type': 'CMD',
                'command': watch_words,
                'diff': '********'
                })
       
del watch_list

if report_destination == 'syslog' or report_destination == 'terminal':
    while True:
        query_words = []
        report = []
        for cmd in watch:
            if cmd['type'] == 'CMD':
                p = Popen(cmd['command'], stdout=PIPE, stderr=PIPE)

            elif cmd['type'] == 'SQL':
                p = Popen([
                    'mysql',
                    '-u',
                    config.db_config['db_user'],
                    '-p%s' % config.db_config['db_password'],
                    config.db_config['db_name'],
                    '-t',
                    '-e',
                    '%s;' % cmd['command']
                    ],
                    stdout=PIPE, stderr=PIPE)

            stdout, stderr = p.communicate()
            if p.returncode == 0:
                diff = '*'.join(stdout.decode('utf-8').replace('\n', ' ').split())
                if cmd['diff'] != diff:
                    cmd['change'] = True
                    cmd['diff'] = diff
                    cmd['report'] = ['']

                    lines = stdout.decode('utf-8').split('\n')
                    for line in lines:
                        if len(line) > 0:
                            cmd['report'].append(line)

                    if len(cmd['report']) > 1:
                        if cmd['type'] == 'SQL':
                            cmd['report'][0] = '%s (%d):' % (cmd['id'], len(cmd['report'])-5)
                        else:
                            cmd['report'][0] = '%s (%d):' % (cmd['id'], len(cmd['report'])-1)
                    else:
                        cmd['report'][0] = '%s (0):' % cmd['id']
                else:
                    cmd['change'] = False
            else:
                if 'report' in cmd:
                    cmd['report'].append('%s:' % cmd['id'])
                    cmd['report'].append('Error: watch list, item=%s, id=%s, error=%s' % (cmd['ix'], cmd['id'], stderr))
                else:
                    cmd['report'] = ['%s:' % cmd['id'], 'Error: watch list, item=%s, id=%s, error=%s' % (cmd['ix'], cmd['id'], stderr)]

        if report_destination == 'terminal':
            p = Popen(['clear'])
            p.communicate()
            
            for cmd in watch:
                if cmd['type'] == 'CMD':
                    print('\n'.join(cmd['report'][1:] + ['']))
                else:
                    print('\n'.join(cmd['report'] + ['']))

        elif report_destination == 'syslog':
            fd = open(config.log_file, 'a')

            for cmd in watch:
                if cmd['change']:
                    fd.write('%s\n' % '\n'.join(cmd['report']))
                else:
                    fd.write('%s no change.\n' % cmd['id'])

            fd.close()

        time.sleep(config.sleep_time)
            
elif report_destination == 'enumerate':
    watch_xref = {}
    for ix in range(len(watch)):
        watch_xref[watch[ix]['id']] = ix

    fd = open(config.log_file)
    lines = fd.read().split('\n')
    fd.close()

    cmd = None
    for line in lines:
        words = line.split()
        if len(words) > 0 and words[0] in watch_xref:
            cmd_ix = watch_xref[words[0]]
            row_ix = 0
        

        if watch[cmd_ix]['type'] == 'CMD':
            print('%d_%d %s' % (cmd_ix, row_ix, line))
            row_ix += 1
        
        elif watch[cmd_ix]['type'] == 'SQL' and len(words) > 0 and len(words[0]) > 0 and words[0][0] != '+':
            if row_ix == 0:
                print('%d_%d %s' % (cmd_ix, row_ix, line))
            else:
                cols = line[1:-1].split('|')
                for col_ix in range(1, len(cols)):
                    cols[col_ix] = '%d_%d=%s' % (cmd_ix, col_ix, cols[col_ix].strip())
                print('%d_%d %s' % (cmd_ix, row_ix, ', '.join(cols[1:])))
            row_ix += 1

elif report_destination == 'map':
    if len(sys.argv) < 3:
        print('Error: specify the log file path to be mapped.')
        exit(1)

    log_file_path = os.path.realpath(sys.argv[2])
    if not os.path.isfile(log_file_path):
        print('Error: the specified log file "%s" does not exist.' % log_file_path)
        exit(1)

    ignore = generate_log_file_map(watch, os.path.dirname(log_file_path), os.path.basename(log_file_path))
#   print('sleeping 60 ...')
#   time.sleep(60)
#   ignore = generate_log_file_map(watch, os.path.dirname(log_file_path), os.path.basename(log_file_path), extend=ignore)

elif report_destination == 'replay':
    def beep():
        curses.flushinp()
        curses.beep()
        return False

    def frame_bwd(cfg):
        cfg['left_right'] = 0
        cfg['up_down'] = 0

        if cfg['fix'] > 0:
            cfg['fix'] -= 1
            return True
        else:
            if os.stat('%s/%s' % (cfg['log_dir'], cfg['maps'][-1]['fn'])).st_size < cfg['maps'][-1]['map'][-1]['fsize']:
                maps_remap(cfg)

            if cfg['mix'] > 0:
                cfg['mix'] -= 1
                if not cfg['maps'][cfg['mix']]['map']:
                    maps_load(cfg)
                cfg['fix'] = len(cfg['maps'][cfg['mix']]['map']) - 1
                return True

            else:
                return beep()

    def frame_fwd(cfg, try_again=True):
        cfg['left_right'] = 0
        cfg['up_down'] = 0

        if cfg['fix'] < len(cfg['maps'][cfg['mix']]['map']) - 1:
            cfg['fix'] += 1
            return True
        else:
            if os.stat('%s/%s' % (cfg['log_dir'], cfg['maps'][-1]['fn'])).st_size < cfg['maps'][-1]['map'][-1]['fsize']:
                maps_remap(cfg)

            if cfg['mix'] < len(cfg['maps']) -1:
                cfg['mix'] += 1
                if not cfg['maps'][cfg['mix']]['map']:
                    maps_load(cfg)
                cfg['fix'] = 0
                return True

            else:
                if try_again:
                    maps_extend(cfg)
                    return frame_fwd(cfg, try_again=False)
                else:
                    return beep()

    def frame_get(cfg):
        fix = cfg['fix']
        mix = cfg['mix']

        report = []
        with open('%s/%s' % (cfg['log_dir'], cfg['maps'][cfg['mix']]['fn'])) as fd:
            for ix in range(len(cfg['maps'][mix]['map'][fix]['cmd'])):
                if cfg['maps'][mix]['map'][fix]['cmd'][ix][1] == -1 or cfg['maps'][mix]['map'][fix]['cmd'][ix][1] == fix:
                    mfix = fix
                else:
                    mfix = cfg['maps'][mix]['map'][fix]['cmd'][ix][1]

                if ix < len(cfg['maps'][mix]['map'][mfix]['cmd']) - 1:
                    rl = cfg['maps'][mix]['map'][mfix]['cmd'][ix+1][0] - cfg['maps'][mix]['map'][mfix]['cmd'][ix][0]
                else:
                    if mfix < len(cfg['maps'][mix]['map']) - 1:
                        rl = cfg['maps'][mix]['map'][mfix+1]['cmd'][0][0] - cfg['maps'][mix]['map'][mfix]['cmd'][ix][0]
                    else:
                        rl = cfg['maps'][mix]['map'][mfix]['fsize'] - cfg['maps'][mix]['map'][mfix]['cmd'][ix][0]

                fd.seek(cfg['maps'][mix]['map'][mfix]['cmd'][ix][0])
                lines = fd.read(rl).split('\n')
                for ix in range(len(lines)):
                    report.append(lines[ix])

        return report

    def maps_extend(cfg):
        cfg['maps'][cfg['mix']]['map'] = generate_log_file_map(cfg['watch'], cfg['log_dir'], cfg['maps'][cfg['mix']]['fn'], extend=cfg['maps'][cfg['mix']]['map'])

    def maps_load(cfg):
        if not os.path.isfile('%s/%s%s' % (cfg['log_dir'], cfg['maps'][cfg['mix']]['fn'], LOG_FILE_MAP_SFX)):
            cfg['maps'][cfg['mix']]['map'] = generate_log_file_map(cfg['watch'], cfg['log_dir'], cfg['maps'][cfg['mix']]['fn'])
        else:
            with open('%s/%s%s' % (cfg['log_dir'], cfg['maps'][cfg['mix']]['fn'], LOG_FILE_MAP_SFX)) as fd:
                cfg['maps'][cfg['mix']]['map'] = json.loads(fd.read())


    def maps_map(cfg):
        log_files = {}
        for log_file in os.listdir(cfg['log_dir']):
            if not os.path.isfile('%s/%s' % (cfg['log_dir'], log_file)) or \
                len(log_file) < len(cfg['log_file_pfx']):
                continue

            if log_file[:len(cfg['log_file_pfx'])] == cfg['log_file_pfx']:
                if log_file[-len(LOG_FILE_MAP_SFX):] == LOG_FILE_MAP_SFX:
                    log_fn = log_file[:-len(LOG_FILE_MAP_SFX)]
                else:
                    log_fn = log_file

                if log_fn == cfg['log_file_pfx']:
                    log = 'z'
                else:
                    log = log_fn

                if log not in log_files:
                    log_files[log] = {'fn': log_fn, 'mapped': False, 'sourced': False}

                if log_fn == log_file:
                    log_files[log]['sourced'] = True
                else:
                    log_files[log]['mapped'] = True

        maps = []
        for log in  sorted(log_files):
            if log_files[log]['sourced']:
                maps.append({'fn': log_files[log]['fn'], 'map': None})

        del log_files
        return maps

    def maps_remap(cfg):
        return

    cfg = {
        'log_dir': os.path.dirname(config.log_file),
        'log_file_pfx': os.path.basename(config.log_file),
        'left_right': 0,
        'up_down': 0,
        'watch': watch
        }

    cfg['maps'] = maps_map(cfg)
    cfg['mix'] = -1
    maps_load(cfg)

    cfg['fix'] = 0
    cfg['mix'] = len(cfg['maps']) - 1

    stdscr = curses.initscr(); curses.noecho(); curses.cbreak(); stdscr.keypad(1); curses.curs_set(0)
    yx = stdscr.getmaxyx(); # stdscr.nodelay(1)

    try:
        while (True):
            yx = stdscr.getmaxyx(); # stdscr.nodelay(1)

            frame_data = frame_get(cfg)

            stdscr.clear()
            for ix in range(min(len(frame_data), yx[0]-2)):
                stdscr.addnstr(ix, 0, frame_data[ix+cfg['up_down']][cfg['left_right']:], yx[1])

            stdscr.addnstr(yx[0]-1, 0, 'Map: %s/%s (%s), Frame: %s/%s, Commands: D<day>d  H<hour>h  N<next>n  \u2190\u2191\u2193\u2192Scroll  q-quit' % (cfg['mix']+1, len(cfg['maps']), cfg['maps'][cfg['mix']]['fn'], cfg['fix']+1, len(cfg['maps'][cfg['mix']]['map'])), yx[1], curses.A_BOLD)

            stdscr.refresh()

            curses.cbreak()
            input = stdscr.getch()

            if input == ord('d'):
                cd = cfg['maps'][cfg['mix']]['map'][cfg['fix']]['dd']
                while frame_fwd(cfg) and cfg['maps'][cfg['mix']]['map'][cfg['fix']]['dd'] == cd:
                    pass

            elif input == ord('D'):
                cd = cfg['maps'][cfg['mix']]['map'][cfg['fix']]['dd']
                while frame_bwd(cfg) and cfg['maps'][cfg['mix']]['map'][cfg['fix']]['dd'] == cd:
                    pass

            elif input == ord('h'):
                cd = cfg['maps'][cfg['mix']]['map'][cfg['fix']]['dd']
                ch = cfg['maps'][cfg['mix']]['map'][cfg['fix']]['hr']
                while frame_fwd(cfg) and cfg['maps'][cfg['mix']]['map'][cfg['fix']]['dd'] == cd and cfg['maps'][cfg['mix']]['map'][cfg['fix']]['hr'] == ch:
                    pass

            elif input == ord('H'):
                cd = cfg['maps'][cfg['mix']]['map'][cfg['fix']]['dd']
                ch = cfg['maps'][cfg['mix']]['map'][cfg['fix']]['hr']
                while frame_bwd(cfg) and cfg['maps'][cfg['mix']]['map'][cfg['fix']]['dd'] == cd and cfg['maps'][cfg['mix']]['map'][cfg['fix']]['hr'] == ch:
                    pass

            elif input == ord('n'):
                frame_fwd(cfg)

            elif input == ord('N'):
                frame_bwd(cfg)

            # Down arror.
            elif input == 258:
                if cfg['up_down']<len(frame_data)-yx[0]+1:
                    cfg['up_down'] += 1
                else:
                    beep()

            # Up arror.
            elif input == 259:
                if cfg['up_down']>0:
                    cfg['up_down'] -= 1
                else:
                    beep()

            # Left arror.
            elif input == 260:
                if cfg['left_right']>0:
                    cfg['left_right'] -= 1
                else:
                    beep()

            # Right arror.
            elif input == 261:
                cfg['left_right'] += 1

            elif input == ord('q'):
                break

        curses.curs_set(1); curses.nocbreak(); stdscr.keypad(0); curses.echo(); curses.endwin()
    except Exception as ex:
        curses.curs_set(1); curses.nocbreak(); stdscr.keypad(0); curses.echo(); curses.endwin()
        print('Map: %s/%s, Frame: %s/%s, Log File: %s' % (cfg['mix']+1, len(cfg['maps']), cfg['fix']+1, len(cfg['maps'][cfg['mix']]['map']), cfg['maps'][cfg['mix']]['fn']))
        traceback.print_tb(ex)
        
