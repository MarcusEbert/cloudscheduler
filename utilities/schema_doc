#!/usr/bin/env python3
"""
Synopsis: utilities/generate_schema.py > lib/schema.py

This routine pulls the current table definitions from the csv2 database and writes the
schema to stdout. To use the schema definitions:

            from lib.schema import <view_or_table_name_1>, <view_or_table_name_2>, ...
"""

from shutil import copyfile
from subprocess import Popen, PIPE
from tempfile import NamedTemporaryFile
import os
import sys
import yaml

REMOVE_BRACKETS = str.maketrans('()', '  ')

def create_index(gvar, type):
    def create_index_entries(gvar, type, fd, caption, table_category=None):
        fd.write('\n.. toctree::\n   :maxdepth: 1\n   :caption: %s\n\n' % caption)
        for table in sorted(gvar['schema'][type]):
            if type == 'tables' and table_category:
                if table in gvar['schema_backup_conf'][table_category]:
                    fd.write('   %s\n' % table)

            elif type == 'views':
                fd.write('   %s\n' % table)
     
    template_path = '%s/docs/schema_doc/templates/%s.rst' % (gvar['base_dir'], type)
    with open(template_path) as fd:
        template = fd.read()

    index_path = '%s/docs/source/_database/_%s/index.rst' % (gvar['base_dir'], type)
    with open(gvar['tempfile'].name, 'w') as fd:
        fd.write(gvar['do_not_edit'] % ('templates/%s.rst' % type))
        fd.write(template)

        if type == 'tables':
            create_index_entries(gvar, type, fd, 'Global configuration tables:',           table_category='global')
            create_index_entries(gvar, type, fd, 'Local configuration tables:',            table_category='local')
            create_index_entries(gvar, type, fd, 'Ephemeral state data:',                  table_category='ephemeral')
            create_index_entries(gvar, type, fd, 'Tables used by other support services:', table_category='ignore')

        else:
            create_index_entries(gvar, type, fd, 'The following views are defined:')

    if not os.path.exists(index_path) or not equal_files(gvar, gvar['tempfile'].name, index_path):
        print("Updating:", index_path)
        copyfile(gvar['tempfile'].name, index_path)

def create_RSTs(gvar, type):
    def write_RSTs_synopsis(gvar, fd, indent, text):
        wpl = 12

        if text and len(text.strip())>0:
            paras = text.strip().split('\n')
            for para in paras:
                words = para.split()
                for ix in range(0, len(words), wpl):
                    fd.write('%s%s\n' % (' '*indent, ' '.join(words[ix:ix+wpl])))

                fd.write('\n')
        else:
            fd.write('\n')

    for table in sorted(gvar['schema'][type]):
        rst_path = '%s/docs/source/_database/_%s/%s.rst' % (gvar['base_dir'], type, table)
        with open(gvar['tempfile'].name, 'w') as fd:
            fd.write(gvar['do_not_edit'] % '%s/%s.rst' % (type, table))

            if type == 'tables':
                if gvar['schema'][type][table]['state'] == 1:
                    fd.write('Database Table: %s (obsolete)\n%s\n\n' % (table, '='*(len(table)+16)))
                else:
                    fd.write('Database Table: %s\n%s\n\n' % (table, '='*(len(table)+16)))
            else:
                if gvar['schema'][type][table]['state'] == 1:
                    fd.write('Database View: %s (obsolete)\n%s\n\n' % (table, '='*(len(table)+15)))
                else:
                    fd.write('Database View: %s\n%s\n\n' % (table, '='*(len(table)+15)))

            write_RSTs_synopsis(gvar, fd, 0, gvar['schema'][type][table]['Synopsis'])

            fd.write('Columns:\n^^^^^^^^\n\n')

            for column in sorted(gvar['schema'][type][table]['Columns']):
                if gvar['schema'][type][table]['Columns'][column]['state'] == 1:
                    fd.write('* **%s** (obsolete):\n\n   * Format: %s\n   * Synopsis:\n' % (column, gvar['schema'][type][table]['Columns'][column]['Format']))
                else:
                    fd.write('* **%s**:\n\n   * Format: %s\n   * Synopsis:\n' % (column, gvar['schema'][type][table]['Columns'][column]['Format']))

                write_RSTs_synopsis(gvar, fd, 6, gvar['schema'][type][table]['Columns'][column]['Synopsis'])

#       if not os.path.exists(rst_path) or not equal_files(gvar['tempfile'].name, rst_path, shallow=False):
        if not os.path.exists(rst_path) or not equal_files(gvar, gvar['tempfile'].name, rst_path):
            print("Updating:", rst_path)
            copyfile(gvar['tempfile'].name, rst_path)

def equal_files(gvar, fn1, fn2):
    len_do_not_edit = len(gvar['do_not_edit'].split('\n'))

    with open(fn1) as fd:
        f1 = '\n'.join(fd.read().split('\n')[len_do_not_edit:])

    with open(fn2) as fd:
        f2 = '\n'.join(fd.read().split('\n')[len_do_not_edit:])

    return f1 == f2

def main(args):
    """
    This does everything:
    o Writes the schema header to stdout.
    o Retrieves the list of tables from the csv2 database.
    o Then for each table:
      - Resets the variable _stdout to just the table header.
      - Retrieves the column list for the table.
      - Then for each column:
        + Appends the column definition to _stdout.-
      - Appends the table footer to _stdout.
      - Writes the table definition to stdout.
    """

    gvar = {}
    config_path = '/etc/cloudscheduler/cloudscheduler.yaml'
    if os.path.isfile(config_path):
        fd = open(config_path)
        gvar['csv2_config'] = yaml.full_load(fd.read())
        fd.close()
    else:
        gvar['csv2_config'] = None
    

    gvar['cmd_path'] = os.path.abspath(args[0])
    gvar['cmd_path_stat'] = os.stat(gvar['cmd_path'])
    gvar['path_info'] = gvar['cmd_path'].split('/')
    gvar['ix'] = gvar['path_info'].index('cloudscheduler')
    gvar['base_dir'] = '/'.join(gvar['path_info'][:gvar['ix']+1])
    gvar['do_not_edit'] = '.. File generated by %s/utilities/schema_doc - DO NOT EDIT\n' \
        '..\n' \
        '.. To modify the contents of this file:\n' \
        '..   1. edit the template file ".../cloudscheduler/docs/schema_doc/%%s"\n' \
        '..   2. run the utility ".../cloudscheduler/utilities/schema_doc"\n' \
        '..\n\n' % (gvar['base_dir'])
    gvar['schema'] = {'tables': {}, 'views': {}}
    gvar['tempfile'] = NamedTemporaryFile(delete=False)

    try:
        import sphinx
        gvar['sphinx'] = True
    except:
        gvar['sphinx'] = False

    schema_yaml_get(gvar, 'tables')
    schema_yaml_get(gvar, 'views')

    with open('%s/etc/schema_backup.conf' % gvar['base_dir']) as fd:
        gvar['schema_backup_conf'] = yaml.full_load(fd.read())
    
    if gvar['csv2_config']:
        _p1 = Popen(
            [
                'mysql',
                '-u%s' % gvar['csv2_config']['database']['db_user'],
                '-p%s' % gvar['csv2_config']['database']['db_password'],
                '-e',
                'show full tables;',
                gvar['csv2_config']['database']['db_name']
                ],
            stdout=PIPE,
            stderr=PIPE
            )
        _p2 = Popen(
            [
                'awk',
                '!/Tables_in_csv2/ {print $1 " " $2}'
                ],
            stdin=_p1.stdout,
            stdout=PIPE,
            stderr=PIPE
            )
        stdout, stderr = _p2.communicate()
        if _p2.returncode != 0:
            print('Failed to retrieve table list.')
            exit(1)

        lines = stdout.decode('ascii').split('\n')
        for line in lines[:-1]:
            table, base_or_view = line.split()
            if base_or_view == 'VIEW':
                type = 'views'
            else:
                type = 'tables'

            if table in gvar['schema'][type]:
                gvar['schema'][type][table]['state'] = 2
            else:
                gvar['schema'][type][table] = {'Synopsis': '', 'Columns': {}, 'state': 0}

            _p1 = Popen(
                [
                    'mysql',
                    '-u%s' % gvar['csv2_config']['database']['db_user'],
                    '-p%s' % gvar['csv2_config']['database']['db_password'],
                    '-e',
                    'show columns from %s;' % table,
                    gvar['csv2_config']['database']['db_name']
                    ],
                stdout=PIPE,
                stderr=PIPE
                )
            _p2 = Popen(
                [
                    'awk',
                    '!/^+/'
                    ],
                stdin=_p1.stdout,
                stdout=PIPE,
                stderr=PIPE
                )
            stdout, stderr = _p2.communicate()
            if _p2.returncode != 0:
                print('Failed to retrieve table columns.')
                exit(1)

            columns = stdout.decode('ascii').split("\n")
            for _ix in range(1, len(columns)):
                _w = columns[_ix].split()
                if len(_w) > 2:
                    if _w[0] in gvar['schema'][type][table]['Columns']:
                        gvar['schema'][type][table]['Columns'][_w[0]]['state'] = 2
                    else:
                        gvar['schema'][type][table]['Columns'][_w[0]] = {'Format': None, 'Synopsis': '', 'state': 0}


                    if _w[1][:5] == 'char(' or \
                        _w[1][:8] == 'varchar(':
                        _w2 = _w[1].translate(REMOVE_BRACKETS).split()
                        gvar['schema'][type][table]['Columns'][_w[0]]['Format'] = 'String'

                    elif _w[1][:4] == 'int(' or \
                    _w[1][:6] == 'bigint' or \
                    _w[1][:4] == 'date' or \
                    _w[1][:8] == 'datetime' or \
                    _w[1][:7] == 'decimal' or \
                    _w[1][:8] == 'smallint' or \
                    _w[1][:9] == 'timestamp':
                        gvar['schema'][type][table]['Columns'][_w[0]]['Format'] = 'Integer'

                    elif _w[1][:7] == 'tinyint':
                        gvar['schema'][type][table]['Columns'][_w[0]]['Format'] = 'Boolean'

                    elif _w[1] == 'text' or \
                    _w[1] == 'tinytext' or \
                    _w[1] == 'longtext' or \
                    _w[1] == 'mediumtext':
                        gvar['schema'][type][table]['Columns'][_w[0]]['Format'] = 'String'

                    elif _w[1][:7] == 'double' or \
                    _w[1][:5] == 'float':
                        gvar['schema'][type][table]['Columns'][_w[0]]['Format'] = 'Float'

                    else:
                        print('Table %s, unknown data type for column: %s' % (table, columns[_ix]))
                        exit(1)

    schema_yaml_put(gvar, 'tables')
    schema_yaml_put(gvar, 'views')

    create_index(gvar, 'tables')
    create_RSTs(gvar, 'tables')

    create_index(gvar, 'views')
    create_RSTs(gvar, 'views')

#   os.unlink(gvar['tempfile'].name)

    if not gvar['csv2_config']:
        print('WARNING: Documentation generated without access to the database; new and obsolete tables/fields may not be reflected accurately.')

    if gvar['sphinx']:
        p = Popen(['make', 'html'], cwd='%s/docs' % gvar['base_dir'])
        p.communicate()
    else:
        print('WARNING: "sphinx" is not installed on your system; unable to rebuild the HTML files.')

def schema_yaml_get(gvar, type):
    if gvar['csv2_config']:
        default_state = 1
    else:
        default_state = 2


    for table in os.listdir('%s/docs/schema_doc/%s' % (gvar['base_dir'], type)):
        table_path = '%s/docs/schema_doc/%s/%s' % (gvar['base_dir'], type, table)
        if os.path.isfile(table_path):
            with open(table_path) as fd:
                table_doc = yaml.full_load(fd.read())

            gvar['schema'][type][table] = table_doc[table]
            gvar['schema'][type][table]['state'] = default_state

            for column in gvar['schema'][type][table]['Columns']:
                gvar['schema'][type][table]['Columns'][column]['state'] = default_state

def schema_yaml_put(gvar, type):
    for table in gvar['schema'][type]:
        yaml_path = '%s/docs/schema_doc/%s/%s' % (gvar['base_dir'], type, table)
        if not os.path.exists(yaml_path):
            with open(yaml_path, 'w') as fd:
                fd.write('%s:\n    Synopsis: %s\n    Columns:\n' % (table, gvar['schema'][type][table]['Synopsis']))
                for column in gvar['schema'][type][table]['Columns']:
                    fd.write('\n        %s:\n            Format: %s\n            Synopsis: %s\n' % (column, gvar['schema'][type][table]['Columns'][column]['Format'], gvar['schema'][type][table]['Columns'][column]['Synopsis']))

if __name__ == "__main__":
    main(sys.argv)
