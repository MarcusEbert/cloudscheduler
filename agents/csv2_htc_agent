#!/usr/bin/env python3
import htcondor
import logging
import pika
import socket
import sys
import yaml

MASTER_TYPE = htcondor.AdTypes.Master
STARTD_TYPE = htcondor.AdTypes.Startd

def callback(ch, method, properties, body):
    yaml_dict = yaml_full_load(body)
    if 'command' in yaml_dict.keys():
        # seems to be valid
        if yaml_dict['command'] == "retire":
            # need to pass localhostname, localhost or nothing might also work
            session = get_condor_session()
            if session:
                try:
                    classad = get_master_classad(session, yaml_dict['machine'], yaml_dict['hostname'])
                    if not classad:
                        #classad not in condor
                        logging.error("Classad not found for %s//%s" % (yaml_dict['machine'], yaml_dict['hostname']))
                        ch.basic_publish(exchange='',
                            routing_key=properties.reply_to,
                            properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                            body=str([1, "No condor classad"]))
                        ch.basic_ack(delivery_tag=method.delivery_tag)
                        return
                    result = condor_off(classad)
                    if result:
                        # should be a success, we need to return to the client now
                        # we may want to add msg and return code to the result body instead of
                        # whatever comes back from condor
                        ch.basic_publish(exchange='',
                            routing_key=properties.reply_to,
                            properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                            body=str([0, result]))
                        ch.basic_ack(delivery_tag=method.delivery_tag)
                        return
                    else:
                        #failed to issue condor off
                        results = "Failed to get issue condor_off"
                        ch.basic_publish(exchange='',
                            routing_key=properties.reply_to,
                            properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                            body=str([1, result]))
                        ch.basic_ack(delivery_tag=method.delivery_tag)
                        return
                except Exception as exc:
                    logging.error("Failed to get condor classad or issue condor off")
                    logging.error(exc)
                    #Failure trying to get classad or issue condor off
                    ch.basic_publish(exchange='',
                        routing_key=properties.reply_to,
                        properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                        body=str([1, exc]))
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    return

            else:
                # failed to get condor session
                results = "Failed to get condor_session"
                ch.basic_publish(exchange='',
                    routing_key=properties.reply_to,
                    properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                    body=str([1, result]))
                ch.basic_ack(delivery_tag=method.delivery_tag)
                return

        elif yaml_dict['command'] == 'invalidate':
            # need to pass localhostname, localhost or nothing might also work
            session = get_condor_session()
            if session:
                master_classad = get_master_classad(session, yaml_dict['machine'], yaml_dict['hostname'])
                if not master_classad:
                    # there was no matching classad
                    logging.error("Classad not found for %s//%s" % (yaml_dict['machine'], yaml_dict['hostname']))
                    ch.basic_publish(exchange='',
                        routing_key=properties.reply_to,
                        properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                        body=str([1, "No condor classad"]))
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    return

                master_result = invalidate_master_classad(session, master_classad)
                startd_classads = get_startd_classads(session, yaml_dict['hostname'])
                startd_result = invalidate_startd_classads(session, startd_classads)
                results = [0, master_result, startd_result]
                # check the results and report back to the return exchange
                ch.basic_publish(exchange='',
                    routing_key=properties.reply_to,
                    properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                    body=str(results))
                ch.basic_ack(delivery_tag=method.delivery_tag)
                return
            else:
                logging.error("Failed to get condor session")
                results = "Failed to get condor session"
                ch.basic_publish(exchange='',
                    routing_key=properties.reply_to,
                    properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                    body=str([1, results]))
                ch.basic_ack(delivery_tag=method.delivery_tag)
                return

        elif yaml_dict['command'] == 'hold':
            #
            #TODO for jobs
            #
            #
            ch.basic_publish(exchange='',
                routing_key=properties.reply_to,
                properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                body=str([1, "NOT YET IMPLEMENTED"]))
            ch.basic_ack(delivery_tag=method.delivery_tag)
            return
        else:
            ch.basic_publish(exchange='',
                routing_key=properties.reply_to,
                properties=pika.BasicProperties(correlation_id=properties.correlation_id),
                body=str([1, "UNKNOWN COMMAND: %s" % yaml_dict['command'] ]))
            ch.basic_ack(delivery_tag=method.delivery_tag)
            return

    else:
        #malformed body, throw it out command and maybe return a failure to reply queue
        ch.basic_publish(exchange='',
            routing_key=properties.reply_to,
            properties=pika.BasicProperties(correlation_id=properties.correlation_id),
            body=str([1, "NO COMMAND"]))
        ch.basic_ack(delivery_tag=method.delivery_tag)
        return




def yaml_full_load(yaml_string):
    if hasattr(yaml, 'full_load'):
        return yaml.full_load(yaml_string)
    else:
        return yaml.load(yaml_string)


def get_condor_session(hostname=None):
    try:
        condor_session = htcondor.Collector(hostname)
        return condor_session
    except Exception as exc:
        logging.exception("Failed to get condor session for %s:" % hostname)
        logging.error(exc)
        return False
        

def get_master_classad(session, machine, hostname):
    try:
        if machine is not "":
            condor_classad = session.query(MASTER_TYPE, 'Name=="%s"' % machine)[0]
        else:
            condor_classad = session.query(MASTER_TYPE, 'regexp("%s", Name, "i")' % hostname)[0]
        return condor_classad
    except Exception as exc:
        logging.error("Failed to retrieve classad from condor (index error means no matching classad):")
        logging.error(exc)
    return False


def get_startd_classads(session, machine):
    startd_list = []
    try:
        condor_classads = session.query(STARTD_TYPE, 'Machine=="%s"' % machine)
        for classad in condor_classads:
            startd_list.append(classad)
        return startd_list
    except Exception as exc:
        logging.error("Failed to retrieve machine classads, aborting...")
        logging.error(exc)
        return False


def condor_off(condor_classad):
    try:
        logging.debug("Sending condor_off to %s" % condor_classad)
        master_result = htcondor.send_command(condor_classad, htcondor.DaemonCommands.DaemonsOffPeaceful)
        if master_result is None:
            # None is good in this case it means it was a success
            master_result = "Success"
        logging.info("Condor_off result: %s" % master_result)
        return master_result
    except Exception as exc:
        logging.error("Condor off failed:")
        logging.error(exc)
        return False


def invalidate_master_classad(session, classad):
    return session.advertise([classad], "INVALIDATE_MASTER_ADS")

def invalidate_startd_classads(session, classad_list):
    return condor_session.advertise(classad_list, "INVALIDATE_STARTD_ADS")
       

fd = open(sys.argv[1])
full_config = yaml_full_load(fd.read())
config = full_config['htc_agent']
del full_config
fd.close()

logger = logging.getLogger()
logging.basicConfig(
    filename=config['log_file'],
    level=config['log_level'],
    format='%(asctime)s - %(processName)-12s - %(levelname)s - %(message)s')

logger.info('Starting, config_path: %s' % sys.argv[1])

my_host_name = socket.gethostname()
csv2_queue = '%s_%s' % (config['csv2_queue'], my_host_name)

connection = pika.BlockingConnection(pika.ConnectionParameters(config['csv2_host'], config['csv2_port']))
channel = connection.channel()

channel.queue_declare(queue=csv2_queue)

channel.basic_consume(queue=csv2_queue,
                      #auto_ack=True,
                      on_message_callback=callback)

logger.info('Waiting for messages.')
channel.start_consuming()

